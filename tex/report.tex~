\documentclass[a4paper,12pt]{report}

\input{header.tex}


\title{РПЗ ПВС}
\author{Ершов Константин ИУ7-37}

\begin{document}

\maketitle

\tableofcontents
\newpage
\section{ВВЕДЕНИЕ}

\subsection{Задание на курсовую работу}
В рамках задания к курсовой работе по курсу "Протоколы вычислительных сетей" реализовать SMTP-клиент для отправки сообщений электронной почты. Вариант задания - \number21 подрузамевает использование вызова poll(), для организации обработки множества входящих соединений в размках одного процесса, и рабочих процессов. Также необходимо предусмотреть возможность ведения журнала работы программы. Журналирование должно быть реализованно в отдельном процессе.
\subsection{Цель и задачи работы} 
Целью данной курсовой работы является разработка SMTP-клиента для отправки сообщений электронной почты.

Задачи работы представлены ниже:
\begin{itemize}
	\itemСоздание SMTP-клиента (как части MTA), обеспечивающего удаленную доставку и поддерживающего очереди сообщений.

	\item Все варианты предполагают обработку нескольких исходящих соединений в одном потоке выполнения (т.е., одном процесс или одном потоке).

	\item На один удалённый MX надо создавать не более одного сокета (допустимый вариант — на один удалённый IP не более одного сокета).

	\item Следует использовать отдельную очередь собщений для каждого MX.		

\end{itemize}

\newpage
\section{АНАЛИТИЧЕСКИЙ РАЗДЕЛ}
В данном разделе представлено описание предметной области, выделены сущности предметной области, представлен способ разделения нагрузки между рабочими процессами.

\subsection{Предметная область}
В соответствии с выданным вариантом, необходимо реализовать SMTP-сервер для получения сообщений электронной почты с использованием poll() и рабочих процессов.

Поскольку обычно ввод-вывод осуществляется с использованием блокирующих системных вывозов, то при попытке считывания или записи данных программа будет блокироваться на этой операции и ожидать появления некоторых данных. Если программа производит работу над локальным файлом, то блокировка, обычно, не занимает долго времени. Однако при использовании сетевых сокетов, когда программа использует вызовы accept(), recv(), write() ожидание данных может занимать продолжительное время, поскольку возможна работа в условиях медленного соединения.

Для решения описанной выше проблемы возможно использование вызова poll(). При использовании poll() регистрируются множества файловых дескрипторов ожидающих записи или чтения. Когда появляется возможность записи или чтения в отслеживаемом дескрипторе, программа может выполнить требуемую операцию, проверив состояние дескриптора в соответствующем множестве.

Использование poll() позволяет производить обработку нескольких активных соединений в рамках одного процесса, и особенно эффективено при небольшом числе одновременно активных сокетов (передача в ядро и обратно по три байта на сокет). Также poll() выл портирован на множество различных ОС, что позволяет использовать его в переносимых программах. 

Ограничением работы с poll() являются максимальное количество отслеживаемых файловых дескрипторов равное 1024 (Linux). В некоторых ОС возможно увеличение этого значения изменив параметр FD\_SETSIZE, однако если необходима высокая переносимость программы, то этого значения может не хватать.

Получение и обработка запросов выполняется в рабочих процессах программы. Каждый процесс обрабатывает новые подключения, принимает и отправляет сообщения клиентам.

Многопроцессный подход к организации обработки сетевых соединений имеет неколько преимуществ перед однопроцессным, т.к. возникновение сбоев в работе одного процесса не приводит к завершению всей программы. При наличии реализации однопроцессной программы с FSM архитектурой, перевод ее на работу с несколькими процессами достаточно прост. Также с увеличением числа процессоров такие программы хорошо масштабируются. С использованием FSM архитектуры логики обработки заявок такой подход может быть высокоэффективным. Однако в некоторых ОС (Solaris, HP\_UX), где обработка потока программы производится быстрее процесса, эффективнее было бы использование потоков, вместо процессов. 

\subsection{Сущности предметной области}
Необходимо выделить основные сущности указанной предметной области. К ним относятся:

\begin{itemize}
	
		\item \textbf{Почтовый клиент} – отправитель письма. Им может выступать как почтовый клиент пользователя, так и другой SMTP-сервер. Имеет адрес, с которого устанавливается соединение с сервером. Отправитель формирует письмо и отправляет его на SMTP-сервер;
		\item \textbf{Письмо} – сообщение, передаваемое отправителем SMTP-серверу. Содержит поля TO - адрес получателя, FROM - адрес отправителя и текст письма. Письмо формируется отправителем и поступает на SMTP-сервер; 
		\item \textbf{SMTP-сервер} – сервер, получающий письма от отправителей. Имеет атрибуты: адрес сервера и порт. Служит для получения писем от отправителей; 

\end{itemize}

\newpage
В этой системе можно выделить следующие субъекты и соответствующие им прецеденты:

\textbf{SMTP-сервер} - инициирует один из прецедентов: получение данных письма, создание файла копии письма, завершение соединения.

Прецеденты:
\begin{itemize}
	
		\item \textbf{Получение данных письма} – при установлении подключения соединения к SMTP-серверу, клиент производит отправку данных письма(или нескольких писем в рамках одной сессии): данные об отправителе, получателе (или нескольких получателях), текст письма. В ответ на передаваемые серверу команды, он отправляет сообщения о результатах выполнения;
		\item \textbf{Создание файла копии письма} – после получения всех необходимых данных письма, SMTP-сервер осуществляет создание файла письма, который в дальнейшем используется SMTP-клиентом для пересылки почты. Данный прецедент может включать создание директорий пользователя, при проведенной ранее аутентификации;
		\item \textbf{Завершение соединения} – В случае возникновения ошибок в обмене сообщениями с клиентом, или по завершению обмена, SMTP-сервер разрывает соединение с клиентом, отправляя сообщение о разрыве соединения.

\end{itemize}

\subsection{Разделение нагрузки между рабочими процессами}

При разработке сервера с использованием нескольких рабочих процессов возникает задача распределения нагрузки по обработке входящих соединений между ними. 

В данной работе было предложено равномерное распределение нагрузки между рабочими процессами. При установке нового подключения его обработкой должен заниматься тот процесс, который обрабатывает наименьшее число активных соединений. Такой подход обеспечит равномерное распределение обработки соединений между рабочими процессами.

Алгоритм распределения нагрузки между рабочими процессами представлен следующим образом:

\begin{itemize}
	
		\item При инициализации программы главным процессом создается указанное число рабочих процессов;
		\item Каждому процессу назнается его ID - уникальный идентификатор. Главный процесс имеет ID = 0, рабочие процессы ID = 1,2,3... по порядку;
		\item Создается массив, хранящий текущее количество активных соединений каждого рабочего процесса. Начальное значение каждого элемента массива равно нулю;
		\item Объявляется переменная nproc, хранящая ID рабочего процесса, который должен обрабатывать новое подключениею. Начальное значение равно единице; 
		\item Главный процесс, используя массив количества активных подключений, выбирает рабочий процесс с наименьшим числом активных подключений и записывает его ID в переменную nproc;
		\item При установлении нового подключения, его обработкой займется процесс с ID = nproc. В момент установления нового подключения он увеличивает на единицу счетчик активных подключений;
		\item При разрыве соединения, или завершении цикла получения письма от получателя счетчик активных подключений уменьшается на единицу;			
		\item Три описанные выше шага поворяются до момента завершения работы программы.

\end{itemize}

Возможно возникновение ситуации, когда один из рабочих процессов был аварийно завершен (в случае возникновения в нем ошибок). Главный процесс, считывая массив активных подключений рабочих процессов, не зная о завершении процесса, будет назначать его кандидатом на обработку нового подключения. В данной ситуации такое поведение ошибочно и будет приводить к задержкам обработки или даже невозможности установления новых подключений. Для избежания этого была предусмотрена логика проверки состояния рабочего процесса с использованием вызова kill(2) перед изменением переменной nproc.


\section{Конструкторский раздел}

\subsection{Конечный автомат состояний клиента}

Процессы работы SMTP-сервера представлены в виде конечного автомата на Рис.~\ref{fig:fsm}, который описан в файле client.def.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/client_def_dot.pdf}
\caption{Состояния сервера}
\label{fig:fsm}
\end{figure}

\subsection{Синтаксис команд протокола}

\begin{description}
\item[220]
\input{include/re_cmd_220_re.tex}
\item[221]
\input{include/re_cmd_221_re.tex}
\item[250]
\input{include/re_cmd_250_re.tex}
\item[354]
\input{include/re_cmd_354_re.tex}
\item[data]
\input{include/re_cmd_data_re.tex}
\item[mail from]
\input{include/re_cmd_mail_from_re.tex}
\item[rcpt to]
\input{include/re_cmd_rcpt_to_re.tex}
\item[mx dns]
\input{include/re_cmd_mx_dns_re.tex}
\end{description}

% \input{include/checkoptn.def.tex}
% \lstset{language=C}
% \lstinputlisting{../src/checkoptn.def}

\section{Технологический раздел}

\subsection{Сборка программы}

Сборка программы описана в файле \textit{Makefile} системы сборки \textit{make}. Рис.~\ref{fig:make} нагенерили самодельные \textit{makesimple} и \textit{makefile2dot}, а также \textit{dot2tex} и \textit{dot}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/Makefile_1_dot.pdf}
\caption{Сборка программы}
\label{fig:make}
\end{figure}

Отмечу, что за исключения целей типа \textit{all}, \textit{install}, \textit{clean}, \textit{tests}, все имена целей в файле систем сборки \textit{make} обычно совпадают с именами файлов (такой вот низкоуровневый инструмент). То есть вместо цели \textit{lexer} следует использовать цель \textit{src/lexer.c}.

\subsection{Основные функции программы}

Весь это раздел сгеренерировал doxygen из части комментированных исходников программы. В файле конфигурации \textbf{doxyggen.cfg} был отключён параметр \textbf{HAVE\_DOT}, поскольку для рисования графов вызовов используется \textit{cflow}.

% \input{include/files}

\input{include/key-listener_8h.tex}
\input{include/key-listener_8c.tex}
\input{include/log_8h.tex}
\input{include/log_8c.tex}
\input{include/maildir_8h.tex}
\input{include/maildir_8c.tex}
\input{include/protocol_8h.tex}
\input{include/protocol_8c.tex}
\input{include/regexp_8h.tex}
\input{include/regexp_8c.tex}
\iffalse

% \input{include/server-state_8c.tex}
\input{include/server-re_8h.tex}
\input{include/server-cmd_8h.tex}
% \input{include/server-cmd_8c.tex}
\input{include/server-parse_8h.tex}
\input{include/server-parse_8c.tex}
\input{include/server-run_8h.tex}
\input{include/server-run_8c.tex}
\input{include/server_8c.tex}
\fi

\subsection{Графы вызова функций}

Поскольку функций много, графы вызовов разбиты на два рисунка. На рис.~\ref{fig:cflow01} показаны основные функции, на рис.~\ref{fig:cflow02}~-- функции обработки команд. Файл \textbf{cflow.ignore} содержит список функций (точнее, шабловнов поиска), использыемых программой \textit{grep} для удаления малоинтересных стандартных функций\footnote{Функции по работе с сокетами, ipc и привилегиями к малоинтересным ни в коем случае не относятся.}.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/cflow01_dot.pdf}
\caption{Граф вызовов, основные функции}
\label{fig:cflow01}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=\textwidth]{include/cflow02_dot.pdf}
\caption{Граф вызовов, функции обработки команд}
\label{fig:cflow02}
\end{figure}

Графы созданы с помощью \textit{cflow}, \textit{cflow2dot}, \textit{dot}.

\newpage
\section{ЗАКЛЮЧЕНИЕ}
Результатом данной работы является разработанная программа - SMTP-сервер, позволяющий производить получение электронной почты по протоколу SMTP. 

Также были решены все поставленные задачи: 

\begin{itemize}
		\item Реализован КА логики работы протокола SMTP клиента
		\item Создан алгоритм обработки нескольких соединений в рамках одного процесса с использованием вызова poll();
		\item Разработана программа - SMTP-клиент;
		\item Представлено описание реализованных функций программы, графа вызовов функций, процесса и графа сборки программы, реализованных алгоритмов для синхронизации доступа к данным;
		\item Проведенно модульное, системное тестирование, а также тестирование утечек памяти полученного SMTP-сервера. Выполнена оценка полученных результатов.

\end{itemize}

Использование вызова poll() позволило организовать обработку нескольких соединений в рамках одного рабочего процесса, а равномерное распределение подлючений между рабочими процессами позволило эффективно производить обслуживание множества подключений.

Программа Autogen с библиотеками AutoFSM и AutoOpts позволила быстро получить код КА для работы программы, а также функционал распознавания параметров командной строки.

По результатам проведенного модульного тестирования, с использования CUnit, а также системного тестирования были выявлены и устранены некоторые ошибки в функциях разработанной программы. А использование Valgrind позволило выявить и устранить места утечек памяти программы.

\end{document}
