/*   -*- buffer-read-only: t -*- vi: set ro:
 *
 *  DO NOT EDIT THIS FILE   (client-fsm.c)
 *
 *  It has been AutoGen-ed  December 10, 2014 at 11:15:42 PM by AutoGen 5.18
 *  From the definitions    src/client.def
 *  and the template file   fsm
 *
 *  Automated Finite State Machine
 *
 *  Copyright (C) 1992-2013 Bruce Korb - all rights reserved
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name ``Bruce Korb'' nor the name of any other
 *    contributor may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * AutoFSM IS PROVIDED BY Bruce Korb ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bruce Korb OR ANY OTHER CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#define DEFINE_FSM
#include "client-fsm.h"
#include <stdio.h>

/*
 *  Do not make changes to this file, except between the START/END
 *  comments, or it will be removed the next time it is generated.
 */
/* START === USER HEADERS === DO NOT CHANGE THIS COMMENT */
#include <protocol.h>
#include <log.h>
/* END   === USER HEADERS === DO NOT CHANGE THIS COMMENT */

#ifndef NULL
#  define NULL 0
#endif

/**
 *  Enumeration of the valid transition types
 *  Some transition types may be common to several transitions.
 */
typedef enum {
    SMTP_CLIENT_FSM_TR_DATASTR_NO_MAIL,
    SMTP_CLIENT_FSM_TR_DATASTR_R250,
    SMTP_CLIENT_FSM_TR_DATASTR_TIMEOUT,
    SMTP_CLIENT_FSM_TR_DATA_R354,
    SMTP_CLIENT_FSM_TR_DATA_TIMEOUT,
    SMTP_CLIENT_FSM_TR_HELO_R250,
    SMTP_CLIENT_FSM_TR_HELO_TIMEOUT,
    SMTP_CLIENT_FSM_TR_INIT_R220,
    SMTP_CLIENT_FSM_TR_INIT_TIMEOUT,
    SMTP_CLIENT_FSM_TR_INVALID,
    SMTP_CLIENT_FSM_TR_MAILFROM_R250,
    SMTP_CLIENT_FSM_TR_MAILFROM_TIMEOUT,
    SMTP_CLIENT_FSM_TR_QUIT_R221,
    SMTP_CLIENT_FSM_TR_QUIT_TIMEOUT,
    SMTP_CLIENT_FSM_TR_RCPTTO_NO_RCPT,
    SMTP_CLIENT_FSM_TR_RCPTTO_R250,
    SMTP_CLIENT_FSM_TR_RCPTTO_TIMEOUT
} te_smtp_client_fsm_trans;
#define SMTP_CLIENT_FSM_TRANSITION_CT  17

/**
 *  State transition handling map.  Map the state enumeration and the event
 *  enumeration to the new state and the transition enumeration code (in that
 *  order).  It is indexed by first the current state and then the event code.
 */
typedef struct smtp_client_fsm_transition t_smtp_client_fsm_transition;
struct smtp_client_fsm_transition {
    te_smtp_client_fsm_state  next_state;
    te_smtp_client_fsm_trans  transition;
};
static const t_smtp_client_fsm_transition
smtp_client_fsm_trans_table[ SMTP_CLIENT_FSM_STATE_CT ][ SMTP_CLIENT_FSM_EVENT_CT ] = {

  /* STATE 0:  SMTP_CLIENT_FSM_ST_INIT */
  { { SMTP_CLIENT_FSM_ST_HELO, SMTP_CLIENT_FSM_TR_INIT_R220 }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INIT_TIMEOUT } /* EVT:  TIMEOUT */
  },


  /* STATE 1:  SMTP_CLIENT_FSM_ST_HELO */
  { { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_MAILFROM, SMTP_CLIENT_FSM_TR_HELO_R250 }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_HELO_TIMEOUT } /* EVT:  TIMEOUT */
  },


  /* STATE 2:  SMTP_CLIENT_FSM_ST_MAILFROM */
  { { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_RCPTTO, SMTP_CLIENT_FSM_TR_MAILFROM_R250 }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_MAILFROM_TIMEOUT } /* EVT:  TIMEOUT */
  },


  /* STATE 3:  SMTP_CLIENT_FSM_ST_RCPTTO */
  { { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_RCPTTO, SMTP_CLIENT_FSM_TR_RCPTTO_R250 }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_DATA, SMTP_CLIENT_FSM_TR_RCPTTO_NO_RCPT }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_RCPTTO_TIMEOUT } /* EVT:  TIMEOUT */
  },


  /* STATE 4:  SMTP_CLIENT_FSM_ST_DATA */
  { { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_DATASTR, SMTP_CLIENT_FSM_TR_DATA_R354 }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_DATA_TIMEOUT } /* EVT:  TIMEOUT */
  },


  /* STATE 5:  SMTP_CLIENT_FSM_ST_DATASTR */
  { { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_MAILFROM, SMTP_CLIENT_FSM_TR_DATASTR_R250 }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_QUIT, SMTP_CLIENT_FSM_TR_DATASTR_NO_MAIL }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_DATASTR_TIMEOUT } /* EVT:  TIMEOUT */
  },


  /* STATE 6:  SMTP_CLIENT_FSM_ST_QUIT */
  { { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R220 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R250 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  R354 */
    { SMTP_CLIENT_FSM_ST_DONE, SMTP_CLIENT_FSM_TR_QUIT_R221 }, /* EVT:  R221 */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_RCPT */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_INVALID }, /* EVT:  NO_MAIL */
    { SMTP_CLIENT_FSM_ST_INVALID, SMTP_CLIENT_FSM_TR_QUIT_TIMEOUT } /* EVT:  TIMEOUT */
  }
};


#define Smtp_Client_FsmFsmErr_off     19
#define Smtp_Client_FsmEvInvalid_off  75
#define Smtp_Client_FsmStInit_off     83


static char const zSmtp_Client_FsmStrings[171] =
/*     0 */ "** OUT-OF-RANGE **\0"
/*    19 */ "FSM Error:  in state %d (%s), event %d (%s) is invalid\n\0"
/*    75 */ "invalid\0"
/*    83 */ "init\0"
/*    88 */ "helo\0"
/*    93 */ "mailfrom\0"
/*   102 */ "rcptto\0"
/*   109 */ "data\0"
/*   114 */ "datastr\0"
/*   122 */ "quit\0"
/*   127 */ "r220\0"
/*   132 */ "r250\0"
/*   137 */ "r354\0"
/*   142 */ "r221\0"
/*   147 */ "no_rcpt\0"
/*   155 */ "no_mail\0"
/*   163 */ "timeout";

static const size_t aszSmtp_Client_FsmStates[7] = {
    83,  88,  93,  102, 109, 114, 122 };

static const size_t aszSmtp_Client_FsmEvents[8] = {
    127, 132, 137, 142, 147, 155, 163, 75 };


#define SMTP_CLIENT_FSM_EVT_NAME(t)   ( (((unsigned)(t)) >= 8) \
    ? zSmtp_Client_FsmStrings : zSmtp_Client_FsmStrings + aszSmtp_Client_FsmEvents[t])

#define SMTP_CLIENT_FSM_STATE_NAME(s) ( (((unsigned)(s)) >= 7) \
    ? zSmtp_Client_FsmStrings : zSmtp_Client_FsmStrings + aszSmtp_Client_FsmStates[s])

#ifndef EXIT_FAILURE
# define EXIT_FAILURE 1
#endif

static int smtp_client_fsm_invalid_transition( te_smtp_client_fsm_state st, te_smtp_client_fsm_event evt );

/* * * * * * * * * THE CODE STARTS HERE * * * * * * * */
/**
 *  Print out an invalid transition message and return EXIT_FAILURE
 */
static int
smtp_client_fsm_invalid_transition( te_smtp_client_fsm_state st, te_smtp_client_fsm_event evt )
{
    /* START == INVALID TRANS MSG == DO NOT CHANGE THIS COMMENT */
    char const * fmt = zSmtp_Client_FsmStrings + Smtp_Client_FsmFsmErr_off;
    fprintf( stderr, fmt, st, SMTP_CLIENT_FSM_STATE_NAME(st), evt, SMTP_CLIENT_FSM_EVT_NAME(evt));
    /* END   == INVALID TRANS MSG == DO NOT CHANGE THIS COMMENT */

    return EXIT_FAILURE;
}

/**
 *  Step the FSM.  Returns the resulting state.  If the current state is
 *  SMTP_CLIENT_FSM_ST_DONE or SMTP_CLIENT_FSM_ST_INVALID, it resets to
 *  SMTP_CLIENT_FSM_ST_INIT and returns SMTP_CLIENT_FSM_ST_INIT.
 */
te_smtp_client_fsm_state
smtp_client_fsm_step(
    te_smtp_client_fsm_state smtp_client_fsm_state,
    te_smtp_client_fsm_event trans_evt,
    void *conn )
{
    te_smtp_client_fsm_state nxtSt;
    te_smtp_client_fsm_trans trans;

    if ((unsigned)smtp_client_fsm_state >= SMTP_CLIENT_FSM_ST_INVALID) {
        return SMTP_CLIENT_FSM_ST_INIT;
    }

#ifndef __COVERITY__
    if (trans_evt >= SMTP_CLIENT_FSM_EV_INVALID) {
        nxtSt = SMTP_CLIENT_FSM_ST_INVALID;
        trans = SMTP_CLIENT_FSM_TR_INVALID;
    } else
#endif /* __COVERITY__ */
    {
        const t_smtp_client_fsm_transition* pTT =
            smtp_client_fsm_trans_table[ smtp_client_fsm_state ] + trans_evt;
        nxtSt = pTT->next_state;
        trans = pTT->transition;
    }


    switch (trans) {
    case SMTP_CLIENT_FSM_TR_DATASTR_NO_MAIL:
        /* START == DATASTR_NO_MAIL == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "No other mail to send, sending QUIT", ((struct mx_conn*)conn)->dom->name);
        send_quit((struct mx_conn*)conn);
        /* END   == DATASTR_NO_MAIL == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_DATASTR_R250:
        /* START == DATASTR_R250 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got 250, checking if there is another mail...", ((struct mx_conn*)conn)->dom->name);
        struct mx_conn *c = (struct mx_conn*)conn;

		// We managed to send mail to at least one mailbox
		c->m->was_sent = 1;

		// Skipping mail that has no recipients from this domain
        do {
			c->m = TAILQ_NEXT(c->m, entry);
		} while (c->m && !mail_has_rcpts_from_domain(c->m, c->dom));

		// If there is no mail, then we should finish connection; otherwise, sending next mail
        if (!c->m) {
			nxtSt = smtp_client_fsm_step(SMTP_CLIENT_FSM_ST_DATASTR, SMTP_CLIENT_FSM_EV_NO_MAIL, conn);
		} else {
			DLOG(BLUE "[%s] " COLOR_RESET "There is another mail, sending MAIL FROM", ((struct mx_conn*)conn)->dom->name);
			c->r = TAILQ_FIRST(&c->m->rcpts);
			send_mailfrom(c);
		}
        /* END   == DATASTR_R250 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_DATASTR_TIMEOUT:
        /* START == DATASTR_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        //~ DLOG(BLUE "[%s] " COLOR_RESET "timeout while sending data...", ((struct mx_conn*)conn)->dom->name);
        //~ send_datastr((struct mx_conn*)conn);
        /* END   == DATASTR_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_DATA_R354:
        /* START == DATA_R354 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got 354, starting to send message data", ((struct mx_conn*)conn)->dom->name);
        send_datastr((struct mx_conn*)conn);
        /* END   == DATA_R354 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_DATA_TIMEOUT:
        /* START == DATA_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        //~ nxtSt = HANDLE_DATA_TIMEOUT();
        /* END   == DATA_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_HELO_R250:
        /* START == HELO_R250 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got 250, sending MAIL FROM", ((struct mx_conn*)conn)->dom->name);
        send_mailfrom((struct mx_conn*)conn);
        /* END   == HELO_R250 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_HELO_TIMEOUT:
        /* START == HELO_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        //~ nxtSt = HANDLE_HELO_TIMEOUT();
        /* END   == HELO_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_INIT_R220:
        /* START == INIT_R220 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got initial 220, sending HELO", ((struct mx_conn*)conn)->dom->name);
        send_hello((struct mx_conn*)conn);
        /* END   == INIT_R220 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_INIT_TIMEOUT:
        /* START == INIT_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        //~ nxtSt = HANDLE_INIT_TIMEOUT();
        /* END   == INIT_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_INVALID:
        /* START == INVALID == DO NOT CHANGE THIS COMMENT */
        ELOG(BLUE "[%s] " COLOR_RESET "Invalid transition in state machine", ((struct mx_conn*)conn)->dom->name);
        nxtSt = SMTP_CLIENT_FSM_ST_INVALID;
        /* END   == INVALID == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_MAILFROM_R250:
        /* START == MAILFROM_R250 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got 250, sending RCPTO TO", ((struct mx_conn*)conn)->dom->name);
		send_rcptto((struct mx_conn*)conn);
        /* END   == MAILFROM_R250 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_MAILFROM_TIMEOUT:
        /* START == MAILFROM_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        //~ nxtSt = HANDLE_MAILFROM_TIMEOUT();
        /* END   == MAILFROM_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_QUIT_R221:
        /* START == QUIT_R221 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got 221", ((struct mx_conn*)conn)->dom->name);
        //~ nxtSt = HANDLE_QUIT_R221();
        /* END   == QUIT_R221 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_QUIT_TIMEOUT:
        /* START == QUIT_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        //~ nxtSt = HANDLE_QUIT_TIMEOUT();
        /* END   == QUIT_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_RCPTTO_NO_RCPT:
        /* START == RCPTTO_NO_RCPT == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "No other recipients, sending DATA", ((struct mx_conn*)conn)->dom->name);
        send_data((struct mx_conn*)conn);
        /* END   == RCPTTO_NO_RCPT == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_RCPTTO_R250:
        /* START == RCPTTO_R250 == DO NOT CHANGE THIS COMMENT */
        DLOG(BLUE "[%s] " COLOR_RESET "Got 250", ((struct mx_conn*)conn)->dom->name);
        if (!send_rcptto((struct mx_conn*)conn))
			nxtSt = smtp_client_fsm_step(SMTP_CLIENT_FSM_ST_RCPTTO, SMTP_CLIENT_FSM_EV_NO_RCPT, conn);
        /* END   == RCPTTO_R250 == DO NOT CHANGE THIS COMMENT */
        break;


    case SMTP_CLIENT_FSM_TR_RCPTTO_TIMEOUT:
        /* START == RCPTTO_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        /* END   == RCPTTO_TIMEOUT == DO NOT CHANGE THIS COMMENT */
        break;


    default:
        /* START == BROKEN MACHINE == DO NOT CHANGE THIS COMMENT */
        //~ smtp_client_fsm_invalid_transition(smtp_client_fsm_state, trans_evt);
        ELOG(BLUE "[%s] " RED "Invalid transition in state machine", ((struct mx_conn*)conn)->dom->name);
        nxtSt = SMTP_CLIENT_FSM_ST_INVALID;

		// To remove annoying compiler warning
        if (0) smtp_client_fsm_invalid_transition(0, 0);
        /* END   == BROKEN MACHINE == DO NOT CHANGE THIS COMMENT */
    }


    /* START == FINISH STEP == DO NOT CHANGE THIS COMMENT */
    //~ DLOG("New state - %s", SMTP_CLIENT_FSM_STATE_NAME(nxtSt));
    /* END   == FINISH STEP == DO NOT CHANGE THIS COMMENT */

    return nxtSt;
}
/*
 * Local Variables:
 * mode: C
 * c-file-style: "stroustrup"
 * indent-tabs-mode: nil
 * End:
 * end of client-fsm.c */
